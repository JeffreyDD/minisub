<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    <title>Hello, world!</title>
    <script src="https://cdn.jsdelivr.net/npm/roslib@1/build/roslib.js" crossorigin="anonymous"></script>
    <script src="https://static.robotwebtools.org/EventEmitter2/current/eventemitter2.min.js"></script>
  </head>
  <body>
    <h1>MiniSub UI</h1>

    <!-- <form>
      <div class="mb-3">
        <label for="minisub_ip" class="form-label">MiniSub IP</label>
        <input type="email" class="form-control" id="minisub_ip">
      </div>
    </form> -->

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <script type="text/javascript">
        // Connecting to ROS
        // -----------------
        var ros = new ROSLIB.Ros();

        // If there is an error on the backend, an 'error' emit will be emitted.
        ros.on('error', function(error) {
            console.log(error);
        });

        // Find out exactly when we made a connection.
        ros.on('connection', function() {
            console.log('Connection made!');
        });

        ros.on('close', function() {
            console.log('Connection closed.');
        });

        // Create a connection to the rosbridge WebSocket server.
        ros.connect('ws://10.0.2.85:9090');
        // Then we add a callback to be called every time a message is published on this topic.
        // listener.subscribe(function(message) {
        //     console.log('Received message on ' + listener.name + ': ');
        //     console.log(message);

        //     // If desired, we can unsubscribe from the topic as well.
        //     // listener.unsubscribe();
        // });

        var cmd_vel = new ROSLIB.Topic({
            ros : ros,
            name : '/cmd_vel',
            messageType : 'geometry_msgs/Twist'
        });

        var twist = new ROSLIB.Message({
          linear: {
            x: 0,
            y: 0,
            z: 0
          },
          angular: {
            x: 0,
            y: 0,
            z: 0
          }
        })
        
        var linear_twist_axis = 1;
        var angular_twist_axis = 0;
        
        var linear_value;
        var angular_value;
        
        var haveEvents = 'ongamepadconnected' in window;
        var controllers = {};
        
        function connecthandler(e) {
          addgamepad(e.gamepad);
        }
        
        function addgamepad(gamepad) {
          controllers[gamepad.index] = gamepad;
          
          requestAnimationFrame(updateStatus);
        }
        
        function disconnecthandler(e) {
          removegamepad(e.gamepad);
        }
        
        function removegamepad(gamepad) {
          delete controllers[gamepad.index];
        }
        
        function updateStatus() {
          if (!haveEvents) {
            scangamepads();
          }
          
          var i = 0;
          var j;
          
          for (j in controllers) {
            var controller = controllers[j];
            
            linear_value = controller.axes[linear_twist_axis];
            angular_value = controller.axes[angular_twist_axis];

            if((linear_value > 0 && linear_value < 0.01) || ((linear_value < 0 && linear_value > -0.01)))
              continue;
            
            if(twist.linear.x == linear_value && twist.angular.z == angular_value)
              continue;

            twist.linear.x = linear_value;
            twist.angular.z = angular_value;
            
            console.info(twist.linear.x, twist.angular.z);

            cmd_vel.publish(twist);
          }
          
          requestAnimationFrame(updateStatus);
        }
        
        function scangamepads() {
          var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
          for (var i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
              if (gamepads[i].index in controllers) {
                controllers[gamepads[i].index] = gamepads[i];
              } else {
                addgamepad(gamepads[i]);
              }
            }
          }
        }

        window.addEventListener("gamepadconnected", connecthandler);
        window.addEventListener("gamepaddisconnected", disconnecthandler);

        if (!haveEvents) {
        setInterval(scangamepads, 500);
        }

    </script>
  </body>
</html>